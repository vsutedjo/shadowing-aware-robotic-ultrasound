import numpy as np
from functions.helpers.helpers import poses_distance, sigmoid, get_occluded_voxels_from_occlusions
from functions.helpers.calculate_weights import d_and_measurements_for_pose
import math


def occlusion_loss(w, _, d, rescanning_weights, gauss_rep, occluded_voxels):
    """ The cost function for occlusion prevention."""

    sig_w = sigmoid(w)
    seen_penalty = np.multiply(sig_w, rescanning_weights)
    seen_penalty_term = np.sum(seen_penalty)
    sim_penalty_term = np.sum(np.multiply(sig_w, gauss_rep))

    cost = coverage_loss(w, None, d, occluded_voxels) + 2.0 * sim_penalty_term + 500.0 * seen_penalty_term

    return cost


def coverage_loss(w, _, d, occluded_voxels = None):
    """
    Implement the loss function to be minimized during the optimization.
    :param w: The initialized weights vector. The vector is a 1-d vector containing the weights for each pose
    parameters, and has shape (n_poses,)
    :param d: The plane-to-voxel distance for between each voxel in the volume grid and each pose.
    It has shape (n_poses, volume_grid_rows, volume_grid_cols, volume_grid_planes).
    It is CRUCIAL that the order with which the poses are ordered in w and d is consistent.

    Example. Considering to have 3 degrees of freedom for the pose, being one rotation angle and translation along
    rows and columns of the voxel grid,  and considering that there are 2 possible angles (discrete angle space
    has size 2), 3 possible position on the volume rows and 4 possible positions on the volume columns, i.e.
    nr_angles = 2, nr_rows = 3, nr_cols = 4. If we assume d to be ordered as:

        d is saved as d = [array(volume_grid_size)(angle_0, row_0, col_0),
                           array(volume_grid_size)(angle_1, row_0, col_0),
                           array(volume_grid_size)(angle_0, row_0, col_1),
                           array(volume_grid_size)(angle_1, row_0, col_1),
                           array(volume_grid_size)(angle_0, row_0, col_2),
                           array(volume_grid_size)(angle_1, row_0, col_2),
                           array(volume_grid_size)(angle_0, row_0, col_3),
                           array(volume_grid_size)(angle_1, row_0, col_3),
                           array(volume_grid_size)(angle_0, row_1, col_0),
                           array(volume_grid_size)(angle_1, row_1, col_0),
                           array(volume_grid_size)(angle_0, row_1, col_1),
                           array(volume_grid_size)(angle_1, row_1, col_1),
                           array(volume_grid_size)(angle_0, row_1, col_2),
                           array(volume_grid_size)(angle_1, row_1, col_2),
                           array(volume_grid_size)(angle_0, row_1, col_3),
                           array(volume_grid_size)(angle_1, row_1, col_3),
                           array(volume_grid_size)(angle_0, row_2, col_0),
                           array(volume_grid_size)(angle_1, row_2, col_0),
                           array(volume_grid_size)(angle_0, row_2, col_1),
                           array(volume_grid_size)(angle_1, row_2, col_1),
                           array(volume_grid_size)(angle_0, row_2, col_2),
                           array(volume_grid_size)(angle_1, row_2, col_2),
                           array(volume_grid_size)(angle_0, row_2, col_3),
                           array(volume_grid_size)(angle_1, row_2, col_3)
                           ]
        with array(volume_grid_size)(angle_i, row_j, col_k) being the an array with size of the volume voxel grid
        expressing voxel distances from the plane generated by (angle_i, row_j, col_k) pose parameters.

        THEN w must/will be ordered consistently as:

        w = [w(angle_0, row_0, col_0),
             w(angle_1, row_0, col_0),
             w(angle_0, row_0, col_1)
             w(angle_1, row_0, col_1)
             w(angle_0, row_0, col_2),
             w(angle_1, row_0, col_2),
             w(angle_0, row_0, col_3),
             w(angle_1, row_0, col_3),
             w(angle_0, row_1, col_0),
             w(angle_1, row_1, col_0),
             w(angle_0, row_1, col_1),
             w(angle_1, row_1, col_1),
             w(angle_0, row_1, col_2),
             w(angle_1, row_1, col_2),
             w(angle_0, row_1, col_3),
             w(angle_1, row_1, col_3),
             w(angle_0, row_2, col_0),
             w(angle_1, row_2, col_0),
             w(angle_0, row_2, col_1),
             w(angle_1, row_2, col_1),
             w(angle_0, row_2, col_2),
             w(angle_1, row_2, col_2),
             w(angle_0, row_2, col_3),
             w(angle_1, row_2, col_3)]

        :return: The volume coverage loss
    """

    w_sig = sigmoid(w)
    v = np.expand_dims(w_sig, axis=(1, 2, 3))

    voxels_torch = v * d  # N_poses x 3 x 3 x 3

    if occluded_voxels is not None:
        sum_all_voxels_torch = np.sum(np.multiply(np.expand_dims(occluded_voxels, 0), d), axis=(1, 2, 3))
    else:
        sum_all_voxels_torch = np.sum(d, axis=(1, 2, 3))

    cov_term = np.sum(np.multiply(sum_all_voxels_torch, w_sig))  # cov_term

    cov_term = math.exp(-cov_term)
    cov_term = cov_term + np.sum(w_sig)

    weighted_torch = np.sum(voxels_torch, axis=0)  # weighted for each voxel

    if occluded_voxels is not None:
        avg_cov_torch = np.mean(weighted_torch[occluded_voxels>0])
    else:
        avg_cov_torch = np.mean(weighted_torch)

    weighted_torch = weighted_torch - avg_cov_torch

    if occluded_voxels is not None:
        avg_term_torch = np.sum(np.abs(weighted_torch[occluded_voxels > 0]))
    else:
        avg_term_torch = np.sum(np.abs(weighted_torch))

    loss = cov_term * 1.0 + avg_term_torch

    return loss


def get_rescanning_weights(d, transducer_width, focal_dist, seen_voxels):
    nr_rows, nr_cols, nr_planes = next(iter(d.values())).shape

    weights = []

    for pose in d.keys():
        (angle, pos_row, pos_col) = pose

        # Penalize poses which see voxels that have been seen sufficiently before
        weight, _, __, ___ = d_and_measurements_for_pose((nr_rows, nr_cols, nr_planes), transducer_width,
                                                         (pos_row, pos_col), focal_dist, angle)
        weights.append(weight)

    weights = np.array(weights)

    # expanding the first dimension such that size(seen_voxels) = (1, rows, cols, planes) and weights is
    # size(w) = (n_poses, 3, 3, 3). The multiplication is then broadcasted on the first dimension
    seen_voxels = np.expand_dims(seen_voxels, 0)
    rescanning_weights = np.sum(np.multiply(weights, seen_voxels), axis=(1, 2, 3))

    return rescanning_weights


def coverage_loss_preparation(d, *args):
    d_array = np.array([d[key] for key in d.keys()])

    return d_array,


def occlusion_prevention_pre_processing(d, gauss, occlusions, dims, angles, transducer_width, focal_dist, *args):
    """
    returns: w, d, updated_d, gauss, seen_voxels, dims, angles, transducer_width, focal_dist)
    """
    updated_d = d
    nr_rows, nr_cols, nr_planes = dims
    seen_voxels = np.ones((nr_rows, nr_cols, nr_planes))
    occluding_poses = occlusions.keys()

    # Preparation of the factors, namely add the pose loc. distance to known occluding poses
    for pose in d.keys():
        # Prepare the seen_voxels matrix - make all voxels that have not been seen (occluded) 0
        if pose in occluding_poses:
            # All occlusions are true occlusions, e.g. no other pose has seen it so far.
            for vox in occlusions[pose]:
                x, y, z = vox
                seen_voxels[x][y][z] = 0
        else:
            seen_voxels += d[pose]

        for occ_pose in occluding_poses:
            occ_voxels = occlusions[occ_pose]
            for occ_vox in occ_voxels:
                x, y, z = occ_vox
                if d[pose][x][y][z] > 0:
                    updated_d[pose] += poses_distance(pose, occ_pose)
    seen_voxels[seen_voxels <= 1] = 0
    seen_voxels[seen_voxels > 1] = 1

    occluded_voxels = get_occluded_voxels_from_occlusions(occlusions)
    ret_values = updated_d, gauss, seen_voxels, dims, angles, transducer_width, focal_dist, occlusions.keys(), occluded_voxels
    return ret_values


def occlusion_loss_preparation(d, gauss, occlusions, dims, angles, transducer_width, focal_dist):
    # preparation to get weights to assign to voxels which are already seen. It can be computed once, as it
    # is not dependent from w.
    updated_d, _, seen_voxels, _, _, _, _, occluding_poses, occluded_voxels = \
        occlusion_prevention_pre_processing(d, gauss, occlusions, dims, angles, transducer_width, focal_dist)

    updated_d_array = np.array([updated_d[key] for key in updated_d.keys()])

    nr_angles = len(angles)

    # updated_d = get_updated_d(d, gauss, occlusions, dims, angles, transducer_width, focal_dist)
    rescanning_weights = get_rescanning_weights(d=updated_d,
                                                transducer_width=transducer_width,
                                                focal_dist=focal_dist,
                                                seen_voxels=seen_voxels)

    # reshaping gauss as it should also be a function of the angle as well. Also reshaping in a way that
    # the dim changing faster is angle, then col, then row --> therefore reshape to [rows, cols, angles] and then
    # flattening
    # todo: not good - computed gauss should have same shape as original matrix

    gauss = gauss[0:-1, 0:-1]
    gauss_rep = np.repeat(np.expand_dims(gauss, -1), axis=-1, repeats=nr_angles)
    gauss_rep = gauss_rep.flatten()

    occluded_voxels = np.array(occluded_voxels)
    occluded_volume = np.zeros(dims)
    occluded_volume[occluded_voxels[:, 0], occluded_voxels[:, 1], occluded_voxels[:, 2]] = 1

    return updated_d_array, rescanning_weights, gauss_rep, occluded_volume


def post_process_weights(w, nr_angles, nr_cols, nr_rows):
    """
    Assuming n_angles=2, n_rows = 3, n_cols = 4, w is supposed to be shaped as
    w = [w(angle_0, row_0, col_0),
         w(angle_0, row_0, col_1),
         w(angle_0, row_0, col_2),
         w(angle_0, row_0, col_3),
         w(angle_0, row_1, col_0),
         w(angle_0, row_1, col_1),
         w(angle_0, row_1, col_2),
         w(angle_0, row_1, col_3),
         w(angle_0, row_2, col_0),
         w(angle_0, row_2, col_1),
         w(angle_0, row_2, col_2),
         w(angle_0, row_2, col_3),
         w(angle_1, row_0, col_0),
         w(angle_1, row_0, col_1),
         w(angle_1, row_0, col_2),
         w(angle_1, row_0, col_3),
         w(angle_1, row_1, col_0),
         w(angle_1, row_1, col_1),
         w(angle_1, row_1, col_2),
         w(angle_1, row_1, col_3),
         w(angle_1, row_2, col_0),
         w(angle_1, row_2, col_1),
         w(angle_1, row_2, col_2),
         w(angle_1, row_2, col_3)]

    d is saved as d = {(angle_0, row_0, col_0): array(),
                       (angle_1, row_0, col_0): array(),
                       (angle_0, row_0, col_1): array(),
                       (angle_1, row_0, col_1): array(),
                       (angle_0, row_0, col_2): array(),
                       (angle_1, row_0, col_2): array(),
                       (angle_0, row_0, col_3): array(),
                       (angle_1, row_0, col_3): array(),
                       (angle_0, row_1, col_0): array(),
                       (angle_1, row_1, col_0): array(),
                       (angle_0, row_1, col_1): array(),
                       (angle_1, row_1, col_1): array(),
                       (angle_0, row_1, col_2): array(),
                       (angle_1, row_1, col_2): array(),
                       (angle_0, row_1, col_3): array(),
                       (angle_1, row_1, col_3): array(),
                       (angle_0, row_2, col_0): array(),
                       (angle_1, row_2, col_0): array(),
                       (angle_0, row_2, col_1): array(),
                       (angle_1, row_2, col_1): array(),
                       (angle_0, row_2, col_2): array(),
                       (angle_1, row_2, col_2): array(),
                       (angle_0, row_2, col_3): array(),
                       (angle_1, row_2, col_3): array(),
                       }

    d can be converted to list or array as: np.array([d[item] for item in d.keys()])
    and therefore becomes: [array()(angle_0, row_0, col_0),
                            array()(angle_1, row_0, col_0),
                            ... ]

    However, the minimization function returns the weights as :
        w = [w(angle_0, row_0, col_0),
             w(angle_1, row_0, col_0),
             w(angle_0, row_0, col_1)
             w(angle_1, row_0, col_1)
             w(angle_0, row_0, col_2),
             w(angle_1, row_0, col_2),
             w(angle_0, row_0, col_3),
             w(angle_1, row_0, col_3),
             w(angle_0, row_1, col_0),
             w(angle_1, row_1, col_0),
             w(angle_0, row_1, col_1),
             w(angle_1, row_1, col_1),
             w(angle_0, row_1, col_2),
             w(angle_1, row_1, col_2),
             w(angle_0, row_1, col_3),
             w(angle_1, row_1, col_3),
             w(angle_0, row_2, col_0),
             w(angle_1, row_2, col_0),
             w(angle_0, row_2, col_1),
             w(angle_1, row_2, col_1),
             w(angle_0, row_2, col_2),
             w(angle_1, row_2, col_2),
             w(angle_0, row_2, col_3),
             w(angle_1, row_2, col_3)]

        as it is more convenient during computation to have d and w being represented consistently.

    Therefore, we need to re-arrange the weights vector, to fit the representation expected by the following functions
    in the pipeline.

    Therefore, in the flattening process, w is saved considering the cols as the first dimension (the one with indexes
    changing faster) and angles as the last dimension (the one with indexes changing slower). On the other hand, d
    is saved considering the angle as the first dimension (the one with indexes changing faster) and row as the
    last dimension (the one with indexes changing slower).
    For simplicity, we want to save them in a consistent way, which will ease next calculation.
    Therefore we reshape, transpose and re-flatten w to match the desired element order


    :param w:
    :param nr_angles: number of probe angles
    :param nr_cols: number of cols in the probe trajectory grid
    :param nr_rows: number of rows in the probe trajectory grid
    :return:
    """
    w_reshaped = np.reshape(w, [nr_rows, nr_cols, nr_angles])
    w_reshaped = np.transpose(w_reshaped, [2, 0, 1])

    return w_reshaped.flatten()
